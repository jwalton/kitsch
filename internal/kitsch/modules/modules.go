// Package modules has modules which can generate parts of the kitsch prompt output.
//
// Each module produces some fragment of output which are assembled together into
// the final shell prompt.  For example the "username" module prints the name of the
// current user.  The "directory" module prints the current working directory.  The
// "block" module combines multiple modules together; it runs each child module
// in parallel, and then assembles up all the results.
//
// Because modules are intended to run in parallel, and because there are certain
// things that many different modules are all going to want to know (e.g. lots
// of programming-language oriented modules will want to know if files with
// a certain name or extension are present in the current folder), each module
// is passed an "env" object, which can be used to access information about the
// environment without duplicating effort (it would be silly if all the various
// programming language modules all read the contents of the current working
// directory - we only need to read it once).
//
package modules

import (
	"fmt"
	"text/template"

	"github.com/jwalton/kitsch/internal/kitsch/log"
	"github.com/jwalton/kitsch/internal/kitsch/modtemplate"
	"github.com/jwalton/kitsch/internal/kitsch/styling"
	"github.com/jwalton/kitsch/internal/perf"
)

// ModuleResult represents the output of a module.
type ModuleResult struct {
	// Text contains the rendered output of the module, either the default text
	// generated by the module itself, or the output from the template if one
	// was specified.
	Text string
	// Data contains any template data generated by the module.
	Data interface{}
	// StartStyle contains the foreground and background colors of the first
	// character in Text.  Note that this is based on the declared style for the
	// module - if the style for the module says the string should be colored
	// blue, but a template is used to change the color of the first character
	// to red, this will still say it is blue.
	StartStyle styling.CharacterColors
	// EndStyle is similar to StartStyle, but contains the colors  of the last
	// character in Text.
	EndStyle styling.CharacterColors
	// ChildDurations is an array of execution times for children of this module.
	ChildDurations *perf.Performance
}

// Module represents a module that generates some output to show in the prompt.
type Module interface {
	// Execute will execute this module and return a ModuleResult.
	Execute(context *Context) ModuleResult
}

//go:generate go run ../genSchema/main.go --pkg schemas CommonConfig

// CommonConfig is common configuration for all modules.
type CommonConfig struct {
	// Style is the style to apply to this module.
	Style string `yaml:"style"`
	// Template is a golang template to use to render the output of this module.
	Template string `yaml:"template"`
}

func (common *CommonConfig) validate(context *Context, prefix string) {
	_, err := context.Styles.Get(common.Style)
	if err != nil {
		log.Warn(fmt.Sprintf("%s: Error parsing style: %v", prefix, err))
	}
}

// TemplateData is the common data structure passed to a template when it is executed.
type TemplateData struct {
	// Text is the default text produced by this module
	Text string
	// Data is the data for this template.
	Data interface{}
	// Global is the global data.
	Globals *Globals
}

func compileModuleTemplate(context *Context, tmpl string) (*template.Template, error) {
	return modtemplate.CompileTemplate(&context.Styles, context.Environment, "module-template", tmpl)
}

// executeModule is called to execute a module.  This handles "common" stuff that
// all modules do, like calling templates.
func executeModule(
	context *Context,
	config CommonConfig,
	data interface{},
	styleStr string,
	defaultText string,
) ModuleResult {
	style, err := context.Styles.Get(styleStr)
	if err != nil {
		style = nil
		log.Warn(err)
	}

	text := defaultText

	var startStyle styling.CharacterColors
	var endStyle styling.CharacterColors

	if config.Template != "" {
		tmpl, err := compileModuleTemplate(context, config.Template)
		if err != nil {
			log.Warn(fmt.Sprintf("Error compiling template: %v", err))
		} else {
			templateData := TemplateData{
				Data:    data,
				Globals: &context.Globals,
				Text:    defaultText,
			}

			text, err = modtemplate.TemplateToString(tmpl, templateData)
			if err != nil {
				log.Warn(fmt.Sprintf("Error executing template:\n%s\n%v", config.Template, err))
				text = defaultText
			}
		}
	}

	if style != nil && text != "" {
		text, startStyle, endStyle = style.ApplyGetColors(text)
	}

	return ModuleResult{
		Text:       text,
		Data:       data,
		StartStyle: startStyle,
		EndStyle:   endStyle,
	}
}

func testTemplate(context *Context, prefix string, template string, dataMap map[string]interface{}) {
	if template == "" {
		return
	}

	tmpl, err := compileModuleTemplate(context, template)
	if err != nil {
		log.Warn(fmt.Sprintf("%s: Error compiling template: %v", prefix, err))
	} else {
		for description, data := range dataMap {
			templateData := TemplateData{
				Data:    data,
				Globals: &context.Globals,
				Text:    "",
			}

			_, err = modtemplate.TemplateToString(tmpl, templateData)
			if err != nil {
				log.Warn(fmt.Sprintf("%s: Error executing template with %s: %v", prefix, description, err))
			}
		}
	}
}

// defaultString returns value if it is non-empty, or def otherwise.
func defaultString(value string, def string) string {
	if value != "" {
		return value
	}
	return def
}

func defaultStyle(context *Context, styleString string, defStyle string) *styling.Style {
	style, err := context.Styles.Get(styleString)
	if err != nil {
		log.Warn(err.Error())
	}
	if styleString == "" || err != nil {
		style, err = context.Styles.Get(defStyle)
		if err != nil {
			panic("Error parsing default style: " + err.Error())
		}
	}

	return style
}
