// Package modules has modules which can generate parts of the kitsch prompt output.
//
// Each module produces some fragment of output which are assembled together into
// the final shell prompt.  For example the "username" module prints the name of the
// current user.  The "directory" module prints the current working directory.  The
// "block" module combines multiple modules together; it runs each child module
// in parallel, and then assembles up all the results.
//
// Because modules are intended to run in parallel, and because there are certain
// things that many different modules are all going to want to know (e.g. lots
// of programming-language oriented modules will want to know if files with
// a certain name or extension are present in the current folder), each module
// is passed an "env" object, which can be used to access information about the
// environment without duplicating effort (it would be silly if all the various
// programming language modules all read the contents of the current working
// directory - we only need to read it once).
//
package modules

import (
	"fmt"

	"github.com/jwalton/kitsch-prompt/internal/env"
	"github.com/jwalton/kitsch-prompt/internal/modtemplate"
	"github.com/jwalton/kitsch-prompt/internal/style"
	styleLib "github.com/jwalton/kitsch-prompt/internal/style"
)

// ModuleResult represents the output of a module.
type ModuleResult struct {
	// Text contains the rendered output of the module, either the default text
	// generated by the module itself, or the
	Text string
	// Data contains any template data generated by the module.
	// TODO: Why is this here?  Is it ever used?
	Data map[string]interface{}
	// StartStyle contains the style of the first character in Text.  Note that
	// this is based on the declared style for the module - if the style for the
	// module says the string should be colored blue, but a template is used to
	// change the color of the first character to red, this will still say it is
	// blue.
	StartStyle style.Style
	// EndStyle is similar to StartStyle, but contains the style of the last
	// character in Text.
	EndStyle style.Style
}

// Module represnts a module that generates some output to show in the prompt.
type Module interface {
	// Execute will execute this module and return a ModuleResult.
	Execute(env env.Env) ModuleResult
}

// CommonConfig is common configuration for all modules.
type CommonConfig struct {
	Style    styleLib.Style `yaml:"style"`
	Template string         `yaml:"template"`
	// // Prefix is a string to add to the start of the output of this module.
	// Prefix   string `yaml:"prefix"`
	// // Style to apply to the prefix.
	// PrefixStyle styleLib.Style `yaml:"prefixStyle"`
	// // Suffix is a string to add to the end of the output of this module.
	// Suffix   string `yaml:"suffix"`
	// // Style to apply to the suffix.
	// SuffixStyle styleLib.Style `yaml:"suffixStyle"`
}

// executeModule is called to execute a module.  This handles "common" stuff that
// all modules do, like calling templates.
func executeModule(
	config CommonConfig,
	data map[string]interface{},
	style styleLib.Style,
	defaultText string,
) ModuleResult {
	text := defaultText
	data["default"] = defaultText

	var startStyle styleLib.Style
	var endStyle styleLib.Style

	// prefix, prefixStartStyle, _, prefixErr := config.PrefixStyle.Apply(config.Prefix)
	// suffix, _, suffixEndStyle, _, suffixErr := config.SuffixStyle.Apply(config.Suffix)

	if config.Template != "" {
		tmpl, err := modtemplate.CompileTemplate("module-template", config.Template)
		if err != nil {
			// FIX: Should add this error to a list of warnings for this module.
			fmt.Printf("Error compiling template: %v", err)
		} else {
			text, err = modtemplate.TemplateToString(tmpl, data)
			if err != nil {
				fmt.Printf("Error executing template: %v", err)
				text = defaultText
			}
		}
	}

	if !style.IsEmpty() {
		// TODO: Do something useful with this error?
		text, startStyle, endStyle, _ = style.Apply(text)
	}

	return ModuleResult{
		Text:       text,
		Data:       data,
		StartStyle: startStyle,
		EndStyle:   endStyle,
	}
}

// defaultString returns value if it is non-empty, or def otherwise.
func defaultString(value string, def string) string {
	if value != "" {
		return value
	}
	return def
}

// defaultNumber returns the passed in value if it is non-0, or def otherwise.
func defaultNumber(value int, def int) int {
	if value != 0 {
		return value
	}
	return def
}
