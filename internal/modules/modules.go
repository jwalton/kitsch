// Package modules has modules which can generate parts of the kitsch prompt output.
//
// Each module produces some fragment of output which are assembled together into
// the final shell prompt.  For example the "username" module prints the name of the
// current user.  The "directory" module prints the current working directory.  The
// "block" module combines multiple modules together; it runs each child module
// in parallel, and then assembles up all the results.
//
// Because modules are intended to run in parallel, and because there are certain
// things that many different modules are all going to want to know (e.g. lots
// of programming-language oriented modules will want to know if files with
// a certain name or extension are present in the current folder), each module
// is passed an "env" object, which can be used to access information about the
// environment without duplicating effort (it would be silly if all the various
// programming language modules all read the contents of the current working
// directory - we only need to read it once).
//
package modules

import (
	"github.com/jwalton/kitsch-prompt/internal/env"
	"github.com/jwalton/kitsch-prompt/internal/style"
)

// ModuleResult represents the output of a module.
type ModuleResult struct {
	// Text contains the rendered output of the module, either the default text
	// generated by the module itself, or the
	Text string
	// Data contains any template data generated by the module.
	// TODO: Why is this here?  Is it ever used?
	Data map[string]interface{}
	// StartStyle contains the style of the first character in Text.  Note that
	// this is based on the declared style for the module - if the style for the
	// module says the string should be colored blue, but a template is used to
	// change the color of the first character to red, this will still say it is
	// blue.
	StartStyle style.Style
	// EndStyle is similar to StartStyle, but contains the style of the last
	// character in Text.
	EndStyle style.Style
}

// Module represnts a module that generates some output to show in the prompt.
type Module interface {
	// Execute will execute this module and return a ModuleResult.
	Execute(env env.Env) ModuleResult
}
